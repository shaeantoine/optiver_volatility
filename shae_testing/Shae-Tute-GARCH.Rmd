---
title: "mixture_training"
output: html_document
date: "2024-04-14"
---

# Required packages
```{r}
library(ggplot2)
library(dplyr)
library(rugarch)
library(stochvol)
library(depmixS4)
library(tsDyn) 
```


# Reading in the data
```{r}

stock <- read.csv("~/Documents/DATA3888/optiver_volatility/data/individual_book_train/stock_100.csv")

```


# Data cleaning/ transformations
```{r}

stock <- stock %>%
  mutate(WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))

stock <- stock %>%
  mutate(BidAskSpread = ask_price1 / bid_price1 - 1)

```

```{r}

log_r1 <- list()
time_IDs <- unique(stock[, 1])[1:500]
for (i in 1 : length(time_IDs)) {
  sec <- stock %>% filter(time_id == time_IDs[i]) %>% pull(seconds_in_bucket)
  price <- stock %>% filter(time_id == time_IDs[i]) %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1[[i]] <- data.frame(time = sec[-1], log_return = log_r)
  time.no.change <- (1:600)[!(1:600 %in% log_r1[[i]]$time)]
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1[[i]] <- rbind(log_r1[[i]], new.df)
    log_r1[[i]] <- log_r1[[i]][order(log_r1[[i]]$time), ]
  }
}

```


```{r}

vol <- list()

comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}

for (i in 1 : length(log_r1)) {
  log_r1[[i]] <- log_r1[[i]] %>% mutate(time_bucket = ceiling(time / 30))
  vol[[i]] <- aggregate(log_return ~ time_bucket, data = log_r1[[i]], FUN = comp_vol)
  colnames(vol[[i]]) <- c('time_bucket', 'volatility')
}

```

```{r}
ggplot(data = log_r1[[1]], aes(x = time, y = log_return)) + geom_line() 

```

```{r}
ggplot(data = vol[[500]], aes(x = time_bucket, y = volatility)) + geom_line() + geom_point() 
```

# EDA and Aasumption Testing

# Stationary - Augmented Dickey-Fuller (ADF) test
```{r}
adf_test_result <- adf.test(log_r1[[1]]$log_return)

print(adf_test_result)
```


# Ljung-Box test 
```{r}
model <- arima(log_r1[[1]]$log_return, order=c(1,0,0))

# Step 5: Perform Ljung-Box test on the residuals
# Change lag value 'k' as per your requirement
box_test <- Box.test(model$residuals, lag = 20, type = "Ljung-Box")

# Print the results
print(box_test)
```



# Model Development 

# Regression
```{r}
vol.train <- list()
vol.val <- list()

for (i in 1 : length(log_r1)) {
  vol.train[[i]] <- vol[[i]][1:16, ]
  vol.val[[i]] <- vol[[i]][-(1:16), ]
}
```

```{r}
list.reg <- list() # list for regression
stock <- stock %>% mutate(time_bucket = ceiling(seconds_in_bucket / 30),
                            num_order = bid_size1 + ask_size1 + bid_size2 + ask_size2)
len.train <- length(vol.train[[1]]$volatility)

for (i in 1 : length(vol)) {
  stats.bucket <- stock %>% 
    filter(time_id == time_IDs[i] & time_bucket != 0) %>% 
    dplyr::select(c(BidAskSpread, WAP, num_order, time_bucket)) 
  # for each 30-sec time bucket, we compute the following statistics
  mean.price <- aggregate(WAP ~ time_bucket, data = stats.bucket, FUN = mean)
  mean.order <- aggregate(num_order ~ time_bucket, data = stats.bucket, FUN = mean)
  mean.BAS <- aggregate(BidAskSpread ~ time_bucket, data = stats.bucket, FUN = mean)
  list.reg[[i]] <- data.frame(volatility = vol.train[[i]]$volatility[-1], 
                              price = mean.price$WAP[1:(len.train - 1)],
                              order = mean.order$num_order[1:(len.train - 1)],
                              BidAskSpread = mean.BAS$BidAskSpread[1:(len.train - 1)])
}
```


```{r}
lm.models <- list()

for (i in 1 : length(vol)) {
  lm.models[[i]] <- lm(volatility ~ price + order + BidAskSpread, list.reg[[i]],
                       weights = 0.8 ^ (((len.train - 2):0) / 2))
}

# for some periods, linear regression performs well
summary(lm.models[[162]])
```


# HAV-RV
```{r}
list.HAV <- list()

for (i in 1 : length(vol)) {
  mean.vol <- rep(0, len.train - 5)
  for (j in 1 : 5) {
    mean.vol <- mean.vol + vol.train[[i]]$volatility[j : (j + len.train - 6)] / 5
  }
  list.HAV[[i]] <- data.frame(vol = vol.train[[i]]$volatility[-(1:5)], 
                              vol_1 = vol.train[[i]]$volatility[5:(len.train - 1)],
                              mean_vol_5 = mean.vol)
}
```

```{r}
quar <- list()
comp_quar <- function(x) {
  return(length(x) / 3 * sum(x ^ 4))
}
for (i in 1 : length(log_r1)) {
  quar[[i]] <- aggregate(log_return ~ time_bucket, data = log_r1[[i]], FUN = comp_quar)
  colnames(quar[[i]]) <- c('time_bucket', 'quarticity')
}

HAV.ols.models <- list()
HAV.wls.models <- list()

for (i in 1 : length(vol)) {
  HAV.ols.models[[i]] <- lm(vol ~ vol_1 + mean_vol_5, list.HAV[[i]])
  
  # weight.HAV <- 0
  HAV.wls.models[[i]] <- lm(vol ~ vol_1 + mean_vol_5, list.HAV[[i]],
                            weights = list.HAV[[i]]$vol_1 / 
                              sqrt(quar[[i]]$quarticity[5:(len.train - 1)]))
}

# HAV-RV performs well for some time buckets
summary(HAV.wls.models[[218]])
```


# ARMA-GARCH
```{r}
spec <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)), 
                   mean.model = list(armaOrder = c(1, 1)), 
                   distribution.model = "norm")

ARMA_GARCH.models <- list()

for (i in 1 : length(vol)) {
  ARMA_GARCH.models[[i]] <- ugarchfit(spec = spec, 
                                      data = log_r1[[i]] %>% 
                                             filter(time <= 480) %>%
                                             pull(log_return),
                                      solver = 'hybrid')
  }

```

```{r}

RV.pred <- rep(0, length(vol))

for (i in 1 : length(vol)) {
  fspec <- getspec(ARMA_GARCH.models[[i]])
  setfixed(fspec) <- as.list(coef(ARMA_GARCH.models[[i]]))
  future.path <- fitted(ugarchpath(fspec, n.sim = 30, m.sim = 1000))
  # Due to numerical issues, sometimes NA value can be produced 
  # We simply replace NA value with 0; you may come up with a better idea in your own project
  future.path[is.na(future.path)] <- 0 
  RV.pred[i] <- mean(sqrt(colSums(future.path ^ 2)))
}

plot(RV.pred)
```


# Evaluation 

# Linear Regression Evaluation
```{r}
list.reg.val <- list()
len.val <- length(vol.val[[1]]$volatility)
pred.lm <- list()

for (i in 1 : length(vol)) {
  stats.bucket <- stock %>% 
    filter(time_id == time_IDs[i] & time_bucket != 0) %>% 
    dplyr::select(c(BidAskSpread, WAP, num_order, time_bucket))
  mean.price <- aggregate(WAP ~ time_bucket, data = stats.bucket, FUN = mean)
  mean.order <- aggregate(num_order ~ time_bucket, data = stats.bucket, FUN = mean)
  mean.BAS <- aggregate(BidAskSpread ~ time_bucket, data = stats.bucket, FUN = mean)
  list.reg.val[[i]] <- 
    data.frame(volatility = vol.val[[i]]$volatility, 
               price = mean.price$WAP[len.train:(len.train + len.val - 1)],
               order = mean.order$num_order[len.train:(len.train + len.val - 1)],
               BidAskSpread = mean.BAS$BidAskSpread[len.train:(len.train + len.val - 1)])
  pred.lm[[i]] <- predict(lm.models[[i]], newdata = list.reg.val[[i]])
}
```

# HAV-RV Evaluation 
```{r}

```


# ARMA-GARCH Evaluation
```{r}
vol.train <- list()
vol.val <- list()

for (i in 1 : length(log_r1)) {
  vol.train[[i]] <- vol[[i]][1:16, ]
  vol.val[[i]] <- vol[[i]][-(1:16), ]
}

vol_mean_test <- vector()
vol_mean_train <- vector()
for (i in 1 : length(vol)){
  vol_mean_test <- c(vol_mean_test, mean(vol.val[[i]]$volatility))
  vol_mean_train <- c(vol_mean_train, mean(vol.train[[i]]$volatility))
}

```

```{r}
time_slot <- c(1 : length(vol))
df = data.frame(time_slot, vol_mean_test, RV.pred)


ggplot(tail(df,n = 50), aes(x=time_slot))+
  geom_line(aes(y = vol_mean_test),color = "red")+
  geom_line(aes(y = RV.pred),color = "blue", linetype="twodash")
```



# MSE AND QLIKE
```{r}
MSE.lm <- vector()
QLIKE.lm <- vector()
for (i in 1 : length(vol)) {
  MSE.lm <- c(MSE.lm, mean((vol.val[[i]]$volatility - RV.pred[[i]]) ^ 2))
  QLIKE.lm <- c(QLIKE.lm, mean(vol.val[[i]]$volatility / RV.pred[[i]] - 
                                 log(vol.val[[i]]$volatility / RV.pred[[i]]) - 1))
}

max_index <- which.max(MSE.lm)

MSE.lm_filtered <- MSE.lm[-max_index]

boxplot(MSE.lm_filtered, horizontal = TRUE, main = "MSE")
```


```{r}
boxplot(QLIKE.lm, horizontal = TRUE, main = "QLIKE")
```







