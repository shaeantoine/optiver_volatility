---
title: "Autocorrelatation"
format:
  html:
    toc: true
    embed-resources: true
    self-contained-math: true
---

```{r}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(rugarch)
```

# Lab

## Realised volatility

### Import data

```{r}
stock0 <- read.csv("data/individual_book_train/stock_0.csv")
```

### Compute statistics from book data

#### Add WAP and BidAskSpread cols

```{r}
stock0 <- stock0 |>
  mutate(WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1)) |>
  mutate(BidAskSpread = ask_price1 / bid_price1 - 1)

head(stock0)
```

#### Log return

```{r}
WAP1 <- stock0 |>
  filter(time_id == 5 & seconds_in_bucket == 16) |>
  pull(WAP)

WAP2 <- stock0 |>
  filter(time_id == 5 & seconds_in_bucket == 15) |>
  pull(WAP)

log_r <- log(WAP1 / WAP2)
print(log_r)
```

### Compute volatility and visualisation

```{r}
log_r1 <- list() # store the log returns
time_IDs <- unique(stock0[, 1])[1:500] # obtain the first 500 time_ids for stock 

for (i in 1:length(time_IDs)) {
  
  sec <- stock0 |>
    filter(time_id == time_IDs[i]) |>
    pull(seconds_in_bucket)
  
  price <- stock0 |>
    filter(time_id == time_IDs[i]) |>
    pull(WAP)
  
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1[[i]] <- data.frame(time = sec[-1], 
                            log_return = log_r)
  time.no.change <- (1:600)[!(1:600 %in% log_r1[[i]]$time)]
  
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1[[i]] <- rbind(log_r1[[i]], new.df)
    log_r1[[i]] <- log_r1[[i]][order(log_r1[[i]]$time), ]
  }
}
```

```{r}
vol <- list()

comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}

for (i in 1:length(log_r1)) {
  
  log_r1[[i]] <- log_r1[[i]] |>
    mutate(time_bucket = ceiling(time / 30))
  
  vol[[i]] <- aggregate(log_return ~ time_bucket, 
                        data = log_r1[[i]], 
                        FUN = comp_vol)
  
  colnames(vol[[i]]) <- c('time_bucket', 'volatility')
}
```

```{r}
ggplot(data = log_r1[[1]], aes(x = time, y = log_return)) + geom_line() 
```

```{r}
ggplot(data = vol[[1]], aes(x = time_bucket, y = volatility)) + geom_line() + geom_point()
```

## Estimation and prediction

### Autocorrelation

```{r}
acf(log_r1[[1]]$log_return, main = "ACF plot for log returns")
```

```{r}
acf(vol[[1]]$volatility, main = "ACF plot for realised volatility")
```
