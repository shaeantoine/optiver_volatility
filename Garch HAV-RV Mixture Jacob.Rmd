---
title: "R Notebook"
output: html_notebook
---

```{r}
library(tidyverse)
library(janitor)
library(ggplot2)
library(dplyr)
library(rugarch)
```

```{r}
stock <- read.csv("C:/Users/Jacob/Desktop/data/Optiver/individual_book_train/stock_100.csv")
stock <- stock %>% 
  mutate(WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))
stock <- stock %>% mutate(BidAskSpread = ask_price1 / bid_price1 - 1)

# Compute the log return of stock over the first 500 unique time points.
log_r1 <- list()
time_IDs <- unique(stock[, 1])[1:500]
for (i in 1 : length(time_IDs)) {
  sec <- stock %>% filter(time_id == time_IDs[i]) %>% pull(seconds_in_bucket)
  price <- stock %>% filter(time_id == time_IDs[i]) %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1[[i]] <- data.frame(time = sec[-1], log_return = log_r)
  time.no.change <- (1:600)[!(1:600 %in% log_r1[[i]]$time)]
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1[[i]] <- rbind(log_r1[[i]], new.df)
    log_r1[[i]] <- log_r1[[i]][order(log_r1[[i]]$time), ]
  }
}

vol <- list()
comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}
for (i in 1 : length(log_r1)) {
  log_r1[[i]] <- log_r1[[i]] %>% mutate(time_bucket = ceiling(time / 30))
  vol[[i]] <- aggregate(log_return ~ time_bucket, data = log_r1[[i]], FUN = comp_vol)
  colnames(vol[[i]]) <- c('time_bucket', 'volatility')
}



# Use the first 5 minutes of each 10-min time bucket for training data and the last 5 minutes for validation.
vol.train <- list()
vol.val <- list()

for (i in 1 : length(log_r1)) {
  vol.train[[i]] <- vol[[i]][1:16, ]
  vol.val[[i]] <- vol[[i]][-(1:11), ]
}



len.train <- length(vol.train[[1]]$volatility)
list.HAV <- list()

for (i in 1 : length(vol)) {
  mean.vol <- rep(0, len.train - 5)
  for (j in 1 : 5) {
    mean.vol <- mean.vol + vol.train[[i]]$volatility[j : (j + len.train - 6)] / 5
  }
  list.HAV[[i]] <- data.frame(vol = vol.train[[i]]$volatility[-(1:5)], 
                              vol_1 = vol.train[[i]]$volatility[5:(len.train - 1)],
                              mean_vol_5 = mean.vol)
}

# Fit the HAV model by using weighted least squares (WLS). For WLS, we use $w_t = \text{RV}_{t-1}/\sqrt{\text{RQ}_{t-1}}$ as the weight for each time period t.
quar <- list()
comp_quar <- function(x) {
  return(length(x) / 3 * sum(x ^ 4))
}
for (i in 1 : length(log_r1)) {
  quar[[i]] <- aggregate(log_return ~ time_bucket, data = log_r1[[i]], FUN = comp_quar)
  colnames(quar[[i]]) <- c('time_bucket', 'quarticity')
}

HAV.wls.models <- list()

for (i in 1 : length(vol)) {
  # weight.HAV <- 0
  HAV.wls.models[[i]] <- lm(vol ~ vol_1 + mean_vol_5, list.HAV[[i]],
                            weights = list.HAV[[i]]$vol_1 / 
                              sqrt(quar[[i]]$quarticity[5:(len.train - 1)]))
}

# HAV-RV performs well for some time buckets
summary(HAV.wls.models[[218]])

pred.lm <- list()

len.val <- length(vol.val[[1]]$volatility)
list.HAV1 <- list()
for (i in 1 : length(vol)) {
  mean.vol <- rep(0, len.val - 5)
  for (j in 1 : 5) {
    mean.vol <- mean.vol + vol.val[[i]]$volatility[j : (j + len.val - 6)] / 5
  }
  list.HAV1[[i]] <- data.frame(vol = vol.val[[i]]$volatility[-(1:5)], 
                              vol_1 = vol.val[[i]]$volatility[5:(len.val - 1)],
                              mean_vol_5 = mean.vol)
  pred.lm[[i]] <- predict(HAV.wls.models[[i]], newdata = list.HAV1[[i]])
}

MSE.lm <- vector()
for (i in 1 : length(vol)) {
  MSE.lm <- c(MSE.lm, mean((tail(vol.val[[i]]$volatility, 4) - pred.lm[[i]])^2))
}
boxplot(MSE.lm, horizontal = TRUE)
```

```{r}
rs <- vector()
for (i in 1 : length(vol)) {
  rs <- c(rs, summary(HAV.wls.models[[i]])$ r.squared)
}
boxplot(rs, horizontal = TRUE)
mean_rs = mean(rs)
mean_rs
```


```{r}
stock <- read.csv("data/individual_book_train/stock_100.csv")
```

```{r}
stock <- stock %>% mutate(
  WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1)
  )

stock <- stock %>% mutate(
  BidAskSpread = ask_price1 / bid_price1 - 1
  )

log_rs <- list()
#time_IDs <- unique(stock$time_id)
time_IDs <- unique(stock[, 1])[1:500]


for (i in 1 : length(time_IDs)) {
  sec <- stock %>% filter(time_id == time_IDs[i]) %>% pull(seconds_in_bucket)
  price <- stock %>% filter(time_id == time_IDs[i]) %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_rs[[i]] <- data.frame(time = sec[-1], log_return = log_r)
  time.no.change <- (1:600)[!(1:600 %in% log_rs[[i]]$time)]
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_rs[[i]] <- rbind(log_rs[[i]], new.df)
    log_rs[[i]] <- log_rs[[i]][order(log_rs[[i]]$time), ]
  }
}
vol <- list()
comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}
for (i in 1 : length(log_rs)) {
  log_rs[[i]] <- log_rs[[i]] %>% mutate(time_bucket = ceiling(time / 30))
  vol[[i]] <- aggregate(log_return ~ time_bucket, data = log_rs[[i]], FUN = comp_vol)
  colnames(vol[[i]]) <- c('time_bucket', 'volatility')
}
```

```{r}
acf(log_rs[[1]]$log_return)
```

```{r,warning=FALSE,message=FALSE}
spec <- ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1, 1)), 
                   mean.model = list(armaOrder = c(0, 0)), 
                   distribution.model = "norm")
ARMA_GARCH.models <- list()

for (i in 1 : length(vol)) {
  ARMA_GARCH.models[[i]] <- ugarchfit(spec = spec, data = log_rs[[i]] %>% 
                                        filter(time <= 480) %>% pull(log_return),
                                      solver = 'hybrid')
  }
```

```{r}
pred1 <- rep(0, length(vol))
for (i in 1 : length(vol)) {
  fspec <- getspec(ARMA_GARCH.models[[i]])
  setfixed(fspec) <- as.list(coef(ARMA_GARCH.models[[i]]))
  future.path <- fitted(ugarchpath(fspec, n.sim = 120, m.sim = 1000))
  future.path[is.na(future.path)] <- 0 
  pred1[i] <- mean(sqrt(colSums(future.path ^ 2)))
}
```

```{r}
vol.train <- list()
vol.val <- list()

for (i in 1 : length(log_rs)) {
  vol.train[[i]] <- vol[[i]][1:16, ]
  vol.val[[i]] <- vol[[i]][-(1:16), ]
}

vol_mean_test <- vector()
vol_mean_train <- vector()
for (i in 1 : length(vol)){
  vol_mean_test <- c(vol_mean_test, mean(vol.val[[i]]$volatility))
  vol_mean_train <- c(vol_mean_train, mean(vol.train[[i]]$volatility))
}

```

```{r}
mix = vector("list", length = length(pred.lm))
for (i in 1:length(pred.lm)){
  mix[[i]] = pred1[[i]]*0.5 + pred.lm[[i]]*0.5
}
MSE.lm <- vector()
QLIKE.lm <- vector()
for (i in 1 : length(vol)) {
  MSE.lm <- c(MSE.lm, mean((vol.val[[i]]$volatility - mix[[i]]) ^ 2))
  QLIKE.lm <- c(QLIKE.lm, mean(vol.val[[i]]$volatility / mix[[i]] - 
                                 log(vol.val[[i]]$volatility / mix[[i]]) - 1))
}

boxplot(MSE.lm, horizontal = TRUE)
```