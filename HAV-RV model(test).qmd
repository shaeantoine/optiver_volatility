---
title: "HAV-RV model(test)"
format: 
  html: 
    embed-resources: true
    code-fold: true
    code-tools: true
editor: visual
---

```{r}
library(ggplot2)
library(dplyr)
library(rugarch)

stock = read.csv("individual_book_train/stock_0.csv")
```

```{r}
stock <- stock %>% mutate(WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1))
stock <- stock %>% mutate(BidAskSpread = ask_price1 / bid_price1 - 1)

# Compute the log return of stock 0 over the first 500 unique time points.
log_r1 <- list()
time_IDs <- unique(stock[, 1])[1:500]
for (i in 1 : length(time_IDs)) {
  sec <- stock %>% filter(time_id == time_IDs[i]) %>% pull(seconds_in_bucket)
  price <- stock %>% filter(time_id == time_IDs[i]) %>% pull(WAP)
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1[[i]] <- data.frame(time = sec[-1], log_return = log_r)
  time.no.change <- (1:600)[!(1:600 %in% log_r1[[i]]$time)]
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1[[i]] <- rbind(log_r1[[i]], new.df)
    log_r1[[i]] <- log_r1[[i]][order(log_r1[[i]]$time), ]
  }
}

# Divide the 10-minute period into non-overlapping 30-second intervals and use the list to store the volatility of stock 0 for each 30-second period in different time periods.
vol <- list()
comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}
for (i in 1 : length(log_r1)) {
  log_r1[[i]] <- log_r1[[i]] %>% mutate(time_bucket = ceiling(time / 30))
  vol[[i]] <- aggregate(log_return ~ time_bucket, data = log_r1[[i]], FUN = comp_vol)
  colnames(vol[[i]]) <- c('time_bucket', 'volatility')
}


# Use the first eight minutes of each 10-min time bucket for training data and the last two minutes for validation.
vol.train <- list()
vol.val <- list()

for (i in 1 : length(log_r1)) {
  vol.train[[i]] <- vol[[i]][1:16, ]
  vol.val[[i]] <- vol[[i]][-(1:16), ]
}
```

```{r}
# Use the first eight minutes of each 10-min time bucket for training data and the last two minutes for validation.
# create a list length 500, where each element of the list is a data frame for a different time_id. All the data frames have three columns: the realised volatility and the corresponding realised volatility in the previous period and the mean realised volatility during the previous five periods. (The first row starts from the 6th time points for each 10-min time bucket because we need the mean realised volatility in the past 5 periods.)


stock <- stock %>% mutate(time_bucket = ceiling(seconds_in_bucket / 30),
                            num_order = bid_size1 + ask_size1 + bid_size2 + ask_size2)
len.train <- length(vol.train[[1]]$volatility)

list.HAV <- list()

for (i in 1 : length(vol)) {
  mean.vol <- rep(0, len.train - 5)
  for (j in 1 : 5) {
    mean.vol <- mean.vol + vol.train[[i]]$volatility[j : (j + len.train - 6)] / 5
  }
  list.HAV[[i]] <- data.frame(vol = vol.train[[i]]$volatility[-(1:5)], 
                              vol_1 = vol.train[[i]]$volatility[5:(len.train - 1)],
                              mean_vol_5 = mean.vol)
}

# Fit the HAV model by using ordinary least squares (OLS) and weighted least squares (WLS), use two lists named HAV.ols.models and HAV.wls.models (each with length 500) to store all the models for every 10-min time bucket.
quar <- list()
comp_quar <- function(x) {
  return(length(x) / 3 * sum(x ^ 4))
}
for (i in 1 : length(log_r1)) {
  quar[[i]] <- aggregate(log_return ~ time_bucket, data = log_r1[[i]], FUN = comp_quar)
  colnames(quar[[i]]) <- c('time_bucket', 'quarticity')
}

HAV.ols.models <- list()
HAV.wls.models <- list()

for (i in 1 : length(vol)) {
  HAV.ols.models[[i]] <- lm(vol ~ vol_1 + mean_vol_5, list.HAV[[i]])
  
  # weight.HAV <- 0
  HAV.wls.models[[i]] <- lm(vol ~ vol_1 + mean_vol_5, list.HAV[[i]],
                            weights = list.HAV[[i]]$vol_1 / 
                              sqrt(quar[[i]]$quarticity[5:(len.train - 1)]))
}

# HAV-RV performs well for some time buckets
summary(HAV.wls.models[[218]])
```
