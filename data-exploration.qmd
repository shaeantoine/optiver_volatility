---
title: "DATA3888 Exploration"
format:
  html:
    toc: true
    embed-resources: true
    self-contained-math: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE)
```

```{r}
library(tidyverse)
library(rugarch)
```

# Lab 

## Realised volatility

### Import data

```{r}
stock0 <- read.csv("data/individual_book_train/stock_125.csv")
dim(stock0)
# head(stock0)
```

### Compute statistics from book data

#### Add WAP and BidAskSpread cols

```{r}
stock0 <- stock0 |>
  mutate(WAP = (bid_price1 * ask_size1 + ask_price1 * bid_size1) / (bid_size1 + ask_size1)) |>
  mutate(BidAskSpread = ask_price1 / bid_price1 - 1)

head(stock0)
```

#### Log return

```{r}
WAP1 <- stock0 |>
  filter(time_id == 5 & seconds_in_bucket == 16) |>
  pull(WAP)

WAP2 <- stock0 |>
  filter(time_id == 5 & seconds_in_bucket == 15) |>
  pull(WAP)

log_r <- log(WAP1 / WAP2)
print(log_r)
```

### Compute volatility and visualisation

```{r}
log_r1 <- list() # store the log returns
time_IDs <- unique(stock0[, 1])[1:500] # obtain the first 500 time_ids for stock 

for (i in 1:length(time_IDs)) {
  
  sec <- stock0 |>
    filter(time_id == time_IDs[i]) |>
    pull(seconds_in_bucket)
  
  price <- stock0 |>
    filter(time_id == time_IDs[i]) |>
    pull(WAP)
  
  log_r <- log(price[-1] / price[1:(length(price) - 1)])
  log_r1[[i]] <- data.frame(time = sec[-1], 
                            log_return = log_r)
  time.no.change <- (1:600)[!(1:600 %in% log_r1[[i]]$time)]
  
  if (length(time.no.change) > 0) {
    new.df <- data.frame(time = time.no.change, log_return = 0)
    log_r1[[i]] <- rbind(log_r1[[i]], new.df)
    log_r1[[i]] <- log_r1[[i]][order(log_r1[[i]]$time), ]
  }
}
```

```{r}
vol <- list()

comp_vol <- function(x) {
  return(sqrt(sum(x ^ 2)))
}

for (i in 1:length(log_r1)) {
  
  log_r1[[i]] <- log_r1[[i]] |>
    mutate(time_bucket = ceiling(time / 30))
  
  vol[[i]] <- aggregate(log_return ~ time_bucket, 
                        data = log_r1[[i]], 
                        FUN = comp_vol)
  
  colnames(vol[[i]]) <- c('time_bucket', 'volatility')
}
```

```{r}
ggplot(data = log_r1[[1]], aes(x = time, y = log_return)) + geom_line() 
```

```{r}
ggplot(data = vol[[1]], aes(x = time_bucket, y = volatility)) + geom_line() + geom_point() 
```

## Estimation and prediction

### Regression analysis

```{r}
vol.train <- list()
vol.val <- list()

for (i in 1 : length(log_r1)) {
  vol.train[[i]] <- vol[[i]][1:16, ]
  vol.val[[i]] <- vol[[i]][-(1:16), ]
}
```

```{r}
list.reg <- list() # list for regression
stock0 <- stock0 |>
  mutate(time_bucket = ceiling(seconds_in_bucket / 30),
         num_order = bid_size1 + ask_size1 + bid_size2 + ask_size2)
len.train <- length(vol.train[[1]]$volatility)

for (i in 1 : length(vol)) {
  stats.bucket <- stock0 |> 
    filter(time_id == time_IDs[i] & time_bucket != 0) |>
    select(c(BidAskSpread, 
             WAP, 
             num_order, 
             time_bucket)) 
  # for each 30-sec time bucket, we compute the following statistics
  mean.price <- aggregate(WAP ~ time_bucket, 
                          data = stats.bucket, 
                          FUN = mean)
  mean.order <- aggregate(num_order ~ time_bucket, 
                          data = stats.bucket, 
                          FUN = mean)
  mean.BAS <- aggregate(BidAskSpread ~ time_bucket, 
                        data = stats.bucket, 
                        FUN = mean)
  list.reg[[i]] <- data.frame(volatility = vol.train[[i]]$volatility[-1], 
                              price = mean.price$WAP[1:(len.train - 1)],
                              order = mean.order$num_order[1:(len.train - 1)],
                              BidAskSpread = mean.BAS$BidAskSpread[1:(len.train - 1)])
}
```

```{r}
lm.models <- list()

for (i in 1 : length(vol)) {
  lm.models[[i]] <- lm(volatility ~ price + order + BidAskSpread, list.reg[[i]],
                       weights = 0.8 ^ (((len.train - 2):0) / 2))
}
```

### Goodness of fit

```{r}
m.min <- 1
m.max <- 1
R.sq.min <- abs(summary(lm.models[[1]])$adj.r.squared)
R.sq.max <- abs(summary(lm.models[[1]])$adj.r.squared)

avg.r.sq <- 0

for (i in 1:length(lm.models)) {
  m <- lm.models[[i]]
  adj.r.sq <- summary(m)$adj.r.squared
  avg.r.sq <- avg.r.sq + abs(adj.r.sq)
  
  if (abs(adj.r.sq) < R.sq.min) {
    R.sq.min = abs(adj.r.sq)
    m.min <- i
  }
  
  if (abs(adj.r.sq) > R.sq.max) {
    R.sq.max = abs(adj.r.sq)
    m.max <- i
  }
}

avg.r.sq / length(lm.models)

summary(lm.models[[m.min]])
summary(lm.models[[m.max]])
```


## Assessing the model

```{r}
list.reg.val <- list()
len.val <- length(vol.val[[1]]$volatility)
pred.lm <- list()

for (i in 1 : length(vol)) {
  stats.bucket <- stock0 |>
    filter(time_id == time_IDs[i] & time_bucket != 0) |>
    select(c(BidAskSpread, WAP, num_order, time_bucket))
  
  mean.price <- aggregate(WAP ~ time_bucket, data = stats.bucket, FUN = mean)
  mean.order <- aggregate(num_order ~ time_bucket, data = stats.bucket, FUN = mean)
  mean.BAS <- aggregate(BidAskSpread ~ time_bucket, data = stats.bucket, FUN = mean)
  list.reg.val[[i]] <- data.frame(volatility = vol.val[[i]]$volatility,
                                  price = mean.price$WAP[len.train:(len.train + len.val - 1)],
                                  order = mean.order$num_order[len.train:(len.train + len.val - 1)],
                                  BidAskSpread = mean.BAS$BidAskSpread[len.train:(len.train + len.val - 1)])
  
  pred.lm[[i]] <- predict(lm.models[[i]], 
                          newdata = list.reg.val[[i]])
}
```

### MSE boxplot

```{r}
MSE.lm <- vector()
QLIKE.lm <- vector()
for (i in 1 : length(vol)) {
  MSE.lm <- c(MSE.lm, mean((vol.val[[i]]$volatility - pred.lm[[i]]) ^ 2))
  QLIKE.lm <- c(QLIKE.lm, mean(vol.val[[i]]$volatility / pred.lm[[i]] - log(vol.val[[i]]$volatility / pred.lm[[i]]) - 1))
}

boxplot(MSE.lm, horizontal = TRUE)
```

### QLIKE boxplot

```{r}
boxplot(QLIKE.lm, horizontal = TRUE)
```












